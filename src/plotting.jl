module Plotting

using Dates
using UnPack
using Plots
using Measures #?
using LaTeXStrings
using StructArrays
using RecursiveArrayTools: VectorOfArray
using DataStructures: OrderedDict

using Flight.Sim

export make_plots, save_plots

################################################################################
################################# Recipes ######################################

@recipe function f(th::TimeHistory{<:Real})

    xguide --> L"$t \: (s)$"
    return th._t, th._data

end

@recipe function f(th::TimeHistory{<:AbstractVector{<:Real}}; th_split = :none)

    #th._data is a Vector{AbstractVector{<:Real}}; convert it to a matrix
    data = Array(VectorOfArray(th._data))'

    #number of matrix columns corresponds to the AbstractVector's length
    vlength = size(data)[2]

    xguide --> L"$t \ (s)$"

    label --> (vlength <= 3 ?  ["x" "y" "z"][:, 1:vlength] : (1:vlength)')
    if th_split === :h
        layout --> (1, vlength)
        link --> :y #alternative: :none
    elseif th_split === :v
        layout --> (vlength, 1)
    else
        layout --> 1
    end

    return th._t, data

end

############################### Attitude #######################################

using Flight.Attitude: Abstract3DRotation, REuler

#if no specific method available, convert to REuler for plotting
@recipe function f(th::TimeHistory{<:Abstract3DRotation}; rot_ref = "", rot_target = "")

    return TimeHistory(th._t, [REuler(v) for v in th._data])

end

@recipe function f(th::TimeHistory{<:REuler}; rot_ref = "", rot_target = "")

    label --> ["Heading" "Inclination" "Bank"]
    yguide --> hcat(L"$\psi_{%$rot_ref %$rot_target} \ (\pi \ rad)$",
                    L"$\theta_{%$rot_ref %$rot_target} \ (\pi \ rad)$",
                    L"$\phi_{%$rot_ref %$rot_target} \ (\pi \ rad)$")
    th_split --> :h #custom TimeHistory attribute

    data = hcat(th.ψ._data, th.θ._data, th.φ._data)'/π #plot as π factors
    return TimeHistory(th._t, data)

end


############################### Geodesy ########################################

using Flight.Geodesy: LatLon, Altitude

@recipe function f(th::TimeHistory{<:LatLon})

    title --> ["Latitude" "Longitude"]
    label --> ["Latitude" "Longitude"]
    yguide --> [L"$\varphi \ (\pi \ rad)$" L"$\lambda \ (\pi \ rad)$"]
    th_split --> :v

    data = hcat(th.ϕ._data, th.λ._data)'/π |> collect
    return TimeHistory(th._t, data)

end

@recipe function f(th::TimeHistory{<:Altitude{D}}) where {D}

    title --> "Altitude ($(string(D)))"
    label --> "Altitude ($(string(D)))"
    yguide --> L"$h \ (m)$"

    return TimeHistory(th._t, Float64.(th._data))

end


################################# Dynamics #####################################

using Flight.Dynamics: Wrench

@recipe function f(th::TimeHistory{<:Wrench}; wr_frame = "", wr_source = "")

    layout := (1, 2)
    seriestype --> :path

    @series begin
        subplot := 1
        title --> "Force"
        yguide --> L"$F_{O%$wr_frame \ (%$wr_source)}^{%$wr_frame} \ (N)$"
        th_split --> :none
        th.F
    end

    @series begin
        subplot := 2
        title --> "Torque"
        yguide --> L"$M_{O%$wr_frame \ (%$wr_source)}^{%$wr_frame} \ (N \ m)$"
        th_split --> :none
        th.M
    end

end

################################# Kinematics ###################################

#@userplot allows defining a custom plot for a specific dataset without having
#to create a custom type for dispatch. we just wrap the data in the userplot
#type generated by Plots, and is received inside the recipe in its field "args"
@userplot Trajectory3D
@recipe function f(t3d::Trajectory3D)

    # https://daschw.github.io/recipes/#series_recipes

    xs, ys, zs = t3d.args
    @assert length(xs) == length(ys) == length(zs)
    n = length(xs)

    xe, ye, ze = map(extrema, (xs, ys, zs))
    x_mid, y_mid, _ = map(v -> 0.5sum(v), (xe, ye, ze))
    x_span, y_span, z_span = map(v -> v[2] - v[1], (xe, ye, ze))
    span = max(x_span, y_span, z_span)

    xl = (x_mid - 0.5span, x_mid + 0.5span)
    yl = (y_mid - 0.5span, y_mid + 0.5span)
    zl = (ze[1], ze[1] + span)

    seriestype --> :path
    xguide --> L"$\Delta x\ (m)$"
    yguide --> L"$\Delta y\ (m)$"
    zguide --> L"$h\ (m)$"
    legend --> false

    xlims --> xl
    ylims --> yl
    zlims --> zl

    yflip --> true

    @series begin
        linecolor --> :lightgray
        xs, ys, fill(zl[1], n)
    end

    @series begin
        linecolor --> :lightgray
        xs, fill(yl[1], n), zs
    end

    @series begin
        linecolor --> :lightgray
        fill(xl[1], n), ys, zs
    end

    @series begin
        linecolor --> :blue
        linewidth --> 3
        xs, ys, zs
    end

    return nothing

end


################################################################################
######################### Multi-Plot Specifications ############################

make_plots(::T; kwargs...) where {T<:TimeHistory} = println("Method make_plots not extended for $T")

#these yield a single figure so they can be handled directly by the Plots
#pipeline directly as recipes
make_plots(th::TimeHistory{<:Real}; kwargs...) = plot(th; kwargs...)

make_plots(th::TimeHistory{<:AbstractVector{<:Real}}; kwargs...) = plot(th; kwargs...)

#complex Systems whose outputs are NamedTuples will typically require multiple
#figures, so we cannot use a @recipe for them. we need to handle the TimeHistory
#recursively
function make_plots(th::TimeHistory{<:NamedTuple}; kwargs...)

    pd = OrderedDict{Symbol, Any}()
    for name in Sim.get_child_names(th)
        child_plots = make_plots(getproperty(th, name); kwargs...)::Union{Nothing, OrderedDict, Plots.Plot}
        !isnothing(child_plots) ? pd[name] = child_plots : nothing
    end

    return (!isempty(pd) ? pd : nothing)

end

############################### Simulation #####################################

using Flight.Sim: Simulation

function make_plots(sim::Simulation;
                    plot_level = :full, #:simplified
                    linewidth=2, margin = 10mm, guidefontsize = 1,
                    kwargs...)
    make_plots(TimeHistory(sim); plot_level, linewidth, margin, guidefontsize, kwargs...)
end


################################# Kinematics ###################################

using Flight.Kinematics: KinData, PosData, VelData

function make_plots(th::TimeHistory{<:KinData}; kwargs...)

    return OrderedDict(
        :pos => make_plots(th.pos; kwargs...),
        :vel => make_plots(th.vel; kwargs...)
    )

end

function make_plots(th::TimeHistory{<:PosData}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    plot_level = get(kwargs, :plot_level, :full)

    #example of capturing the plot_level keyword to control which plots are generated
    if plot_level == :simplified
        return pd #nothing also works
    end

    pd[:e_nb] = plot(
        th.e_nb;
        plot_title = "Attitude (Vehicle/NED)",
        rot_ref = "n", rot_target = "b",
        kwargs...)

    #remove the title added by the LatLon TH recipe
    subplot_latlon = plot(th.ϕ_λ; title = "", th_split = :v, kwargs...)

    #remove the title added by the Altitude TH recipe
    subplot_h = plot(th.h_e; title = "", kwargs...)
                plot!(th.h_o; title = "", kwargs...)

    subplot_xy = plot(
        th.Δxy;
        label = [L"$\int v_{eb}^{x_n} dt$" L"$\int v_{eb}^{y_n} dt$"],
        ylabel = [L"$\Delta x\ (m)$" L"$\Delta y \ (m)$"],
        th_split = :h, link = :none, kwargs...)

    pd[:Ob_geo] = plot(
        subplot_latlon, subplot_h;
        layout = grid(1, 2, widths = [0.67, 0.33]),
        plot_title = "Position (WGS84)",
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    pd[:Ob_xyh] = plot(
        subplot_xy, subplot_h;
        layout = grid(1, 2, widths = [0.67, 0.33]),
        plot_title = "Position (Local Cartesian)",
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    #when a plot is assembled from multiple subplots, the plot_titlefontsize
    #attribute no longer works, and it is titlefontisze what determines the font
    #size of the overall figure title (which normally is used for subplots).

    th_Δx, th_Δy = Sim.get_scalar_components(th.Δxy)
    xs, ys, zs = th_Δx._data, th_Δy._data, Float64.(th.h_e._data)

    pd[:Ob_t3d] = plot(
        Trajectory3D((xs, ys, zs));
        plot_title = "Trajectory (Local Cartesian, Ellipsoidal Altitude)",
        titlefontsize = 20,
        camera = (30, 45),
        )

    return pd

end

function make_plots(th::TimeHistory{<:VelData}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    pd[:ω_lb_b] = plot(
        th.ω_lb_b;
        plot_title = "Angular Velocity (Vehicle/LTF) [Vehicle Axes]",
        label = ["Roll Rate" "Pitch Rate" "Yaw Rate"],
        ylabel = [L"$p \ (rad/s)$" L"$q \ (rad/s)$" L"$r \ (rad/s)$"],
        th_split = :h,
        kwargs...)

    pd[:ω_el_n] = plot(
        th.ω_el_n;
        plot_title = "Local Tangent Frame Transport Rate (LTF/ECEF) [NED Axes]",
        ylabel = L"$\omega_{el}^{l} \ (rad/s)$",
        th_split = :h,
        kwargs...)

    pd[:v_eOb_n] = plot(
        th.v_eOb_n;
        plot_title = "Velocity (Vehicle/ECEF) [NED Axes]",
        label = ["North" "East" "Down"],
        ylabel = [L"$v_{eb}^{N} \ (m/s)$" L"$v_{eb}^{E} \ (m/s)$" L"$v_{eb}^{D} \ (m/s)$"],
        th_split = :h,
        kwargs...)

    pd[:v_eOb_b] = plot(
        th.v_eOb_b;
        plot_title = "Velocity (Vehicle/ECEF) [Vehicle Axes]",
        ylabel = [L"$v_{eb}^{x_b} \ (m/s)$" L"$v_{eb}^{y_b} \ (m/s)$" L"$v_{eb}^{z_b} \ (m/s)$"],
        th_split = :h,
        kwargs...)

    return pd

end


################################ Dynamics ######################################

using Flight.Dynamics: DynData, DynDataIn, DynDataOut

function make_plots(th::TimeHistory{<:DynData}; kwargs...)

    return OrderedDict(
        :input => make_plots(th.input; kwargs...),
        :output => make_plots(th.output; kwargs...)
    )

end

function make_plots(th::TimeHistory{<:DynDataIn}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    pd[:wr_g_b] = plot(th.wr_g_b;
        plot_title = "Gravity Wrench [Vehicle Axes]",
        wr_source = "g", wr_frame = "b",
        kwargs...)

    pd[:wr_in_b] = plot(th.wr_in_b;
        plot_title = "Inertia Wrench [Vehicle Axes]",
        wr_source = "in", wr_frame = "b",
        kwargs...)

    pd[:wr_ext_b] = plot(th.wr_ext_b;
        plot_title = "External Wrench [Vehicle Axes]",
        wr_source = "ext", wr_frame = "b",
        kwargs...)

    pd[:hr_b] = plot(th.hr_b;
        plot_title = "Angular Momentum from Rotating Components [Vehicle Axes]",
        ylabel = hcat(
            L"$h_{Ob \ (r)}^{x_b} \ (kg \ m^2 / s)$",
            L"$h_{Ob \ (r)}^{y_b} \ (kg \ m^2 / s)$",
            L"$h_{Ob \ (r)}^{z_b} \ (kg \ m^2 / s)$"),
        th_split = :h, link = :none,
        kwargs...)

    return pd

end

function make_plots(th::TimeHistory{<:DynDataOut}; kwargs...)

    #standard gravity for specific force normalization
    g₀ = 9.80665

    pd = OrderedDict{Symbol, Plots.Plot}()

    pd[:α_eb_b] = plot(th.α_eb_b;
        plot_title = "Angular Acceleration (Vehicle/ECEF) [Vehicle Axes]",
        ylabel = hcat(
            L"$\alpha_{eb}^{x_b} \ (rad/s^2)$",
            L"$\alpha_{eb}^{y_b} \ (rad/s^2)$",
            L"$\alpha_{eb}^{z_b} \ (rad/s^2)$"),
        th_split = :h,
        kwargs...)

    pd[:a_eOb_b] = plot(th.a_eOb_b;
        plot_title = "Linear Acceleration (Vehicle/ECEF) [Vehicle Axes]",
        ylabel = hcat(
            L"$a_{eb}^{x_b} \ (m/s^{2})$",
            L"$a_{eb}^{y_b} \ (m/s^{2})$",
            L"$a_{eb}^{z_b} \ (m/s^{2})$"),
        th_split = :h,
        kwargs...)

    pd[:a_eOb_n] = plot(th.a_eOb_n;
        plot_title = "Linear Acceleration (Vehicle/ECEF) [NED Axes]",
        ylabel = hcat(
            L"$a_{eb}^{N} \ (m/s^{2})$",
            L"$a_{eb}^{E} \ (m/s^{2})$",
            L"$a_{eb}^{D} \ (m/s^{2})$"),
        th_split = :h, link = :none,
        kwargs...)

    pd[:f_Ob_b] = plot(TimeHistory(th._t, th.f_Ob_b._data / g₀);
        plot_title = "Specific Force [Vehicle Axes]",
        ylabel = hcat(
            L"$f_{Ob}^{x_b} \ (g)$",
            L"$f_{Ob}^{y_b} \ (g)$",
            L"$f_{Ob}^{z_b} \ (g)$"),
        th_split = :h,
        kwargs...)

    return pd

end

################################### Air ########################################

using Flight.Air: AirData

function make_plots(th::TimeHistory{<:AirData}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    pd[:v_ew_n] = plot(th.v_ew_n;
        plot_title = "Velocity (Wind / ECEF) [NED Axes]",
        label = ["North" "East" "Down"],
        ylabel = [L"$v_{ew}^{N} \ (m/s)$" L"$v_{ew}^{E} \ (m/s)$" L"$v_{ew}^{D} \ (m/s)$"],
        th_split = :h,
        kwargs...)

    pd[:v_ew_b] = plot(th.v_ew_b;
        plot_title = "Velocity (Wind / ECEF) [Vehicle Axes]",
        ylabel = [L"$v_{ew}^{x_b} \ (m/s)$" L"$v_{ew}^{y_b} \ (m/s)$" L"$v_{ew}^{z_b} \ (m/s)$"],
        th_split = :h,
        kwargs...)

    pd[:v_eOb_b] = plot(th.v_eOb_b;
        plot_title = "Velocity (Vehicle / ECEF) [Vehicle Axes]",
        ylabel = [L"$v_{eb}^{x_b} \ (m/s)$" L"$v_{eb}^{y_b} \ (m/s)$" L"$v_{eb}^{z_b} \ (m/s)$"],
        th_split = :h,
        kwargs...)

    pd[:v_wOb_b] = plot(th.v_wOb_b;
        plot_title = "Velocity (Vehicle / Wind) [Vehicle Axes]",
        ylabel = [L"$v_{eb}^{x_b} \ (m/s)$" L"$v_{eb}^{y_b} \ (m/s)$" L"$v_{eb}^{z_b} \ (m/s)$"],
        th_split = :h,
        kwargs...)

        subplot_a = plot(th.a;
            title = "Speed of Sound", ylabel = L"$a \ (m/s)$",
            label = "", kwargs...)

        subplot_ρ = plot(th.ρ;
            title = "Density", ylabel = L"$\rho \ (kg/m^3)$",
            label = "", kwargs...)

        subplot_μ = plot(th.μ;
            title = "Dynamic Viscosity", ylabel = L"$\mu \ (Pa \ s)$",
            label = "", kwargs...)

    pd[:ρ_a] = plot(subplot_ρ, subplot_a, subplot_μ;
        plot_title = "Freestream Properties",
        layout = (1,3),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs


        subplot_T = plot(
            TimeHistory(th._t, hcat(th.T._data, th.Tt._data)' |> collect);
            title = "Temperature",
            label = ["Static"  "Total"],
            ylabel = L"$T \ (K)$",
            th_split = :none, kwargs...)

        subplot_p = plot(
            TimeHistory(th._t, 1e-3*hcat(th.p._data, th.pt._data)' |> collect);
            title = "Pressure",
            label = ["Static"  "Total"],
            ylabel = L"$p \ (kPa)$",
            th_split = :none, kwargs...)

    pd[:T_p] = plot(subplot_T, subplot_p;
        plot_title = "Freestream Properties",
        layout = (1,2),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

        subplot_airspeed = plot(
            TimeHistory(th._t, hcat(th.TAS._data, th.EAS._data, th.CAS._data)' |> collect);
            title = "Airspeed",
            label = ["True" "Equivalent" "Calibrated"],
            ylabel = L"$v \ (m/s)$",
            th_split = :none, kwargs...)

        subplot_Mach = plot(th.M;
            title = "Mach", ylabel = L"M",
            label = "", kwargs...)

        subplot_q = plot(th._t, th.q._data/1000;
            title = "Dynamic Pressure", ylabel = L"$q \ (kPa)$",
            label = "", kwargs...)

    l3 = @layout [a{0.5w} [b; c{0.5h}]]

    pd[:airspeed_M_q] = plot(
        subplot_airspeed, subplot_Mach, subplot_q;
        layout = l3,
        plot_title = "Freestream Properties",
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    return pd

end


############################## Friction ########################################

using Flight.Friction: RegulatorY

function make_plots(th::TimeHistory{<:RegulatorY}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    splt_v = plot(th.v; title = "Velocity",
        ylabel = L"$v \ (m/s)$", kwargs...)

    splt_s = plot(th.s; title = "Velocity Integral",
        ylabel = L"$s \ (m)$", kwargs...)

    splt_α_p = plot(th.α_p; title = "Proportional Term",
        ylabel = L"$\alpha_p$", kwargs...)

    splt_α_i = plot(th.α_i; title = "Integral Term",
        ylabel = L"$\alpha_i$", kwargs...)

    splt_α_raw = plot(th.α_raw; title = "Raw Output",
        ylabel = L"$\alpha_{raw}$", kwargs...)

    splt_α = plot(th.α; title = "Clipped Output",
        ylabel = L"$\alpha$", kwargs...)

    splt_sat = plot(th.sat; title = "Saturation",
        ylabel = L"$S$", kwargs...)

    pd[:vs] = plot(splt_v, splt_s, splt_sat;
        plot_title = "Contact Point Kinematics",
        layout = (1,3),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    pd[:pi] = plot(splt_α_p, splt_α_i, splt_sat;
        plot_title = "Proportional and Integral Terms",
        layout = (1,3),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    pd[:output] = plot(splt_α_raw, splt_α, splt_sat;
        plot_title = "Regulator Output",
        layout = (1,3),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    return pd

end


############################### Electrics ######################################

using Flight.Electrics: EThrusterY

function make_plots(th::TimeHistory{<:EThrusterY}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    pd[:wr_Oc_c] = plot(th.wr_c;
        plot_title = "Thruster Wrench [Thruster Frame]",
        wr_source = "thr", wr_frame = "c",
        kwargs...)

    pd[:wr_Ob_b] = plot(th.wr_b;
        plot_title = "Thruster Wrench [Vehicle Axes]",
        wr_source = "thr", wr_frame = "b",
        kwargs...)

    return pd

end


############################### LandingGear ####################################

using Flight.LandingGear: StrutY, ContactY

function make_plots(th::TimeHistory{<:StrutY}; kwargs...)

    pd = OrderedDict{Symbol, Plots.Plot}()

    subplot_ξ = plot(th.ξ;
        title = "Elongation", ylabel = L"$\xi \ (m)$",
        label = "", kwargs...)

    subplot_ξ_dot = plot(th.ξ_dot;
        title = "Elongation Rate", ylabel = L"$\dot{\xi} \ (m/s)$",
        label = "", kwargs...)

    subplot_F = plot(th.F;
        title = "Force", ylabel = L"$F \ (N)$",
        label = "", kwargs...)

    pd[:dmp] = plot(subplot_ξ, subplot_ξ_dot, subplot_F;
        plot_title = "Damper",
        layout = (1,3), link = :none,
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    return pd

end

function make_plots(th::TimeHistory{<:ContactY}; kwargs...)

    pd = OrderedDict{Symbol, Any}()

    pd[:regulator] = make_plots(th.regulator; kwargs...)

    (μ_max_x, μ_max_y) = Sim.get_scalar_components(th.μ_max)
    (μ_eff_x, μ_eff_y) = Sim.get_scalar_components(th.μ_eff)

    subplot_μ_roll = plot(th.μ_roll; title = "Rolling Friction Coefficient",
        ylabel = L"$\mu_{roll}$", label = "", kwargs...)
    subplot_μ_skid = plot(th.μ_skid; title = "Skidding Friction Coefficient",
        ylabel = L"$\mu_{skid}$", label = "", kwargs...)

    pd[:srf] = plot(subplot_μ_roll, subplot_μ_skid;
        plot_title = "Surface Friction",
        layout = (1,2), link = :y,
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    subplot_κ_br = plot(th.κ_br; title = "Braking Coefficient",
        ylabel = L"$\alpha_{br}$", label = "", kwargs...)
    subplot_μ_max_x = plot(μ_max_x; title = "Maximum Friction Coefficient",
        ylabel = L"$\mu_{max}^{x}$", label = "", kwargs...)
    subplot_μ_eff_x = plot(μ_eff_x; title = "Effective Friction Coefficient",
        ylabel = L"$\mu^{x}$", label = "", kwargs...)

    pd[:μ_x] = plot(subplot_κ_br, subplot_μ_max_x, subplot_μ_eff_x;
        plot_title = "Longitudinal Friction",
        layout = (1,3),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    subplot_ψ_cv = plot(th._t, rad2deg.(th.ψ_cv._data); title = "Tire Slip Angle",
        ylabel = L"$\psi_{cv} \ (deg)$", label = "", kwargs...)
    subplot_μ_max_y = plot(μ_max_y; title = "Maximum Friction Coefficient",
        ylabel = L"$\mu_{max}^{y}$", label = "", kwargs...)
    subplot_μ_eff_y = plot(μ_eff_y; title = "Effective Friction Coefficient",
        ylabel = L"$\mu^{y}$", label = "", kwargs...)

    pd[:μ_y] = plot(subplot_ψ_cv, subplot_μ_max_y, subplot_μ_eff_y;
        plot_title = "Lateral Friction",
        layout = (1,3),
        kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs

    pd[:f_c] = plot(th.f_c;
        plot_title = "Normalized Contact Force",
        ylabel = [L"$f_{Oc \ (trn)}^{c}$" L"$f_{Oc \ (trn)}^{c}$" L"$f_{Oc \ (trn)}^{c}$"],
        th_split = :h, link = :none,
        kwargs...)

    pd[:F_c] = plot(th.F_c;
        plot_title = "Contact Force",
        ylabel = [L"$F_{Oc \ (trn)}^{c} \ (N)$" L"$F_{Oc \ (trn)}^{c} \ (N)$" L"$F_{Oc \ (trn)}^{c} \ (N)$"],
        th_split = :h, link = :none,
        kwargs...)

    pd[:wr_b] = plot(th.wr_b;
        plot_title = "Wrench [Vehicle Axes]",
        wr_source = "trn", wr_frame = "b",
        kwargs...)

    return pd

end


############################ Propellers ########################################

using Flight.Propellers: Propellers

function plot_airfoil(airfoil::Propellers.AbstractAirfoil, show = true)

    α = range(-π/6, π/3, length = 100)
    M = range(0, 1.5, length = 6)
    iter = Iterators.product(α, M)

    cL_data = [cL(airfoil, α, M) for (α, M) in iter]
    cD_data = [cD(airfoil, α, M) for (α, M) in iter]
    cL_α_data = [cL_α(airfoil, α, M) for (α, M) in iter]

    label = latexstring.("M = ".*string.(M'))
    titles = (L"c_L", L"c_{L, \alpha}", L"c_D")
    x_label = L"\alpha \ (rad)"

    p = Vector{Plots.Plot}()
    for (i, data) in enumerate((cL_data, cD_data, cL_α_data))
        push!(p, plot(α, data, label = label, title = titles[i], xlabel = x_label))
    end

    show ? display.(p) : nothing

    return p

end

function plot_J_Δβ(dataset::Propellers.Dataset, M_tip::Real = 0.0, show = true)

    J = knots(dataset).iterators[1] |> collect
    Δβ_bounds = bounds(dataset)[3]
    Δβ = range(Δβ_bounds[1], Δβ_bounds[2], length = 5)

    data = [dataset(J, M_tip, Δβ) for (J, Δβ) in Iterators.product(J, Δβ)]
    data = data |> StructArray |> StructArrays.components

    @unpack C_Fx, C_Mx, C_Fz_α, C_Mz_α, C_P, η_p = data

    label = latexstring.("\$ \\Delta \\beta = " .* string.(rad2deg.(Δβ')) .* "\\degree \$")
    label_pos = [:bottomleft, :topleft, :bottomleft, :bottomleft, :topright, :topleft]
    x_label = L"J"
    y_labels = [L"C_{Fx}", L"C_{Mx}", L"C_{Fz, \alpha}", L"C_{Mz, \alpha}", L"M_{tip}", L"\eta_p"]
    titles = ["Traction Coefficient ", "Torque Coefficient", "Off-Axis Force Coefficient Derivative",
                "Off-Axis Moment Coefficient Derivative", "Power Coefficient", "Propulsive Efficiency"] .*
                " (Blade Tip Mach Number = $M_tip)"

    p = Vector{Plots.Plot}()
    for (i, c) in enumerate((C_Fx, C_Mx, C_Fz_α, C_Mz_α, C_P, η_p))
        push!(p, plot(J, c; title = titles[i], label = label, legend = label_pos[i], xlabel = x_label, ylabel = y_labels[i]))
    end

    show ? display.(p) : nothing

    return p

end

function plot_M_J(dataset::Propellers.Dataset, Δβ::Real = 0.0, show = true)

    M_tip = knots(dataset).iterators[2] |> collect
    J_bounds = bounds(dataset)[1]
    J = range(J_bounds[1], J_bounds[2], length = 5)

    data = [dataset(J, M_tip, Δβ) for (M_tip, J) in Iterators.product(M_tip, J)]
    data = data |> StructArray |> StructArrays.components

    @unpack C_Fx, C_Mx, C_Fz_α, C_Mz_α, C_P, η_p = data

    label = latexstring.("J = ".*string.(J'))
    label_pos = [:bottomleft, :topleft, :bottomleft, :bottomleft, :topright, :topleft]
    x_label = L"M_{tip}"
    y_labels = [L"C_{Fx}", L"C_{Mx}", L"C_{Fz, \alpha}", L"C_{Mz, \alpha}", L"M_{tip}", L"\eta_p"]
    titles = ["Traction Coefficient ", "Torque Coefficient", "Off-Axis Force Coefficient Derivative",
                "Off-Axis Moment Coefficient Derivative", "Power Coefficient", "Propulsive Efficiency"] .*
                " (Blade Pitch Offset = $(rad2deg(Δβ))°)"

    p = Vector{Plots.Plot}()
    for (i, c) in enumerate((C_Fx, C_Mx, C_Fz_α, C_Mz_α, C_P, η_p))
        push!(p, plot(M_tip, c; title = titles[i], label = label, legend = label_pos[i], xlabel = x_label, ylabel = y_labels[i]))
    end

    show ? display.(p) : nothing

    return p

end

function plot_J_M(dataset::Propellers.Dataset, Δβ::Real = 0.0, show = true)

    J = knots(dataset).iterators[1] |> collect
    M_tip_bounds = bounds(dataset)[2]
    M_tip = range(M_tip_bounds[1], M_tip_bounds[2], length = 5)

    data = [dataset(J, M_tip, Δβ) for (J, M_tip) in Iterators.product(J, M_tip)]
    data = data |> StructArray |> StructArrays.components

    @unpack C_Fx, C_Mx, C_Fz_α, C_Mz_α, C_P, η_p = data

    label = latexstring.("M_{tip} = ".*string.(M_tip'))
    label_pos = [:bottomleft, :topleft, :bottomleft, :bottomleft, :topright, :topleft]
    x_label = L"J"
    y_labels = [L"C_{Fx}", L"C_{Mx}", L"C_{Fz, \alpha}", L"C_{Mz, \alpha}", L"M_{tip}", L"\eta_p"]
    titles = ["Traction Coefficient ", "Torque Coefficient", "Off-Axis Force Coefficient Derivative",
                "Off-Axis Moment Coefficient Derivative", "Power Coefficient", "Propulsive Efficiency"] .*
                " (Blade Pitch Offset = $(rad2deg(Δβ))°)"

    p = Vector{Plots.Plot}()
    for (i, c) in enumerate((C_Fx, C_Mx, C_Fz_α, C_Mz_α, C_P, η_p))
        push!(p, plot(J, c; title = titles[i], label = label, legend = label_pos[i], xlabel = x_label, ylabel = y_labels[i]))
    end

    show ? display.(p) : nothing

    return p

end


# splt_α = thplot(t, rad2deg.(α_b);
#     title = "Angle of Attack", ylabel = L"$\alpha \ (deg)$",
#     label = "", kwargs...)

# splt_β = thplot(t, rad2deg.(β_b);
#     title = "Angle of Sideslip", ylabel = L"$\beta \ (deg)$",
#     label = "", kwargs...)

# pd["05_α_β"] = plot(splt_α, splt_β;
#     plot_title = "Airflow Angles [Airframe]",
#     layout = (1,2),
#     kwargs..., plot_titlefontsize = 20) #override titlefontsize after kwargs


################################################################################
############################# Plot Saving ######################################


function save_plots(dict::OrderedDict{Symbol, T} where {T};
                    save_folder::Union{String, Nothing} = nothing, format = :png)

    save_folder = mkpath(save_folder === nothing ?
        joinpath("tmp", Dates.format(now(), "yyyy_mm_dd_HHMMSS")) : save_folder)

    n = 0
    for (label, child) in zip(keys(dict), values(dict))

        if isa(child, OrderedDict)
            save_subfolder = mkpath(joinpath(save_folder, String(label)))
            save_plots(dict[label]; save_folder = save_subfolder, format)

        elseif isa(child, Plots.Plot)
            n += 1
            plot_filename = joinpath(save_folder, string(n, pad = 2)*"_"*String(label)*"."*String(format))
            savefig(child, plot_filename)
            println("Saved figure $plot_filename")

        elseif !isnothing(child)
            error("Invalid entry type ($(typeof(child))")

        end
    end

end


end #module